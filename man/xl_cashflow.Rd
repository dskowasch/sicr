% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reinsurance.R
\name{xl_cashflow}
\alias{xl_cashflow}
\title{Calculate reinsurer's payments for xl-treaty}
\usage{
xl_cashflow(
  future_payments,
  claims_list,
  history,
  reinsurance,
  indices = NULL,
  xl_indices_per_claim = NULL,
  output = "future"
)
}
\arguments{
\item{future_payments}{numeric matrix with one row per claim and 250 columns for future payments.}

\item{claims_list}{dataframe of claims generated with \code{\link[=generate_claims_list]{generate_claims_list()}}.}

\item{history}{numeric matrix with one row per claim with historic payments, generated by \code{\link[=generate_history_per_claim]{generate_history_per_claim()}}. \cr
If generated in other ways, note that colnames must be the origin years.}

\item{reinsurance}{dataframe of reinsurance structures, see details.}

\item{indices}{dataframe for indexation, default NULL. See details of \code{\link[=prepare_data]{prepare_data()}}.
Only one of \code{indices} and \code{xl_indices_per_claim} may be NULL.}

\item{xl_indices_per_claim}{numeric indexation matrix, default NULL. See details of \code{\link[=generate_xl_indices_per_claim]{generate_xl_indices_per_claim()}}.
Only one of \code{indices} and \code{xl_indices_per_claim} may be NULL.}

\item{output}{desired output as character, one of \code{history}, \code{future} and \code{total}.}
}
\value{
numeric matrix with one row per claim containing reinsurer's payments.
The number of columns depends on the \code{output} parameter.
}
\description{
Future and historic payments are binded per claim to calculate the reinsurer's payments. \cr
The marketwide very common indexation clause makes this slightly complicated, so
read the details section for further information.
}
\details{
This function uses historic and future payments per claim to derive the reinsurer's payments for the xl-treaty. \cr
The calculation becomes rather complicated as there are several common indexation clauses (also referred to as
Stability Clause or Inflation Clause), all of them with the idea of sharing the increase of claims payments due
to inflation during the long settlement of the claims between cedent and reinsurer. \cr
The basic types of clauses can be divided into European Index Clauses (EIC) and London Market Indexation Clause
(LMIC). This package does \strong{not} support LMIC, but the most important EIC clauses! \cr \cr
For a layer C xs D and a large claim with payments \eqn{p_{i}} for development year i = 1,..., T and
reserves \eqn{r_{i}} at the end of development year i we define \eqn{a_{i} = z_{1} + â€¦ + z_{i} + r_{i}} as the
claims incurred at the end of development year i. For a given index series we call \eqn{I_{B}} the index for
base year B and \eqn{I_{i}} the index for development year i. The indexation clauses that are supported by this
package define the correction factors as follows: \cr \cr
\enumerate{
\item \strong{APK} (for german \code{Anpassungsklausel}) with margin \eqn{\alpha} (with \eqn{\alpha = 10\%} in many cases):
\deqn{
f_{i} :=
\left\{
   \begin{array}{r}
      1 \qquad if \quad \frac{I_{i}}{I_{B}} < 1 + \alpha \\
      \frac{I_{B}}{I_{i}} \qquad if \quad  \frac{I_{i}}{I_{B}} \ge 1 + \alpha
   \end{array}
\right.
}
\item \strong{SIC} (for \verb{Severe Inflation Clause}) with margin \eqn{\alpha} (with \eqn{\alpha = 30\%} in many cases):
\deqn{
f_{i} :=
\left\{
   \begin{array}{r}
      1 \qquad if \quad \frac{I_{i}}{I_{B}} < 1 + \alpha \\
      \frac{I_{B} \cdot (1+\alpha)}{I_{i}} \qquad if \quad  \frac{I_{i}}{I_{B}} \ge 1 + \alpha
   \end{array}
\right.
}
\item \strong{FIC} (for \code{Full} or \verb{Franchise Inflation Clause}):
\deqn{f_{i} := \frac{I_{B}}{I_{i}}}
In some cases FIC is also defined with a margin. But unlike in APK and SIC as soon as the cumulated index exceeds
the margin the index is applied to the former payments as well. As this happens in most claims in longtail lines of
business, only FIC without margin is implemented in this package which should be a reasonable simplification.
}

With the payments and the latest reserve a stabilization factor per claim and per development year can be calculated by:
\deqn{F_{i} = \frac{z_{1} + \cdots + z_{i} + r_{i}}{f_{1}z_{1} + \cdots + f_{i}z_{i} + f_{i}r_{i}}}
and this leads to a stabilized prioririty and limit per claim and development year:
\deqn{C_{i}^{stab} \ xs \ D_{i}^{stab} \quad with \quad C_{i}^{stab} = F_{i}
\cdot C \ and \ D_{i}^{stab} = F_{i} \cdot D.}
\strong{Note that this package does not forecast reserves (only reserve classes) and therefore reserves are not considered
in the application of the indexation clause.} This leads to slight deviations from the real reinsurance cashflow during
the claim development but the effect should be not be significant. \cr \cr

Considering these information the structure of the parameter dataframe \code{reinsurance} should be as follows: \cr
\code{reinsurance} must contain one row for each origin year that shall be considered even though no reinsurance may
have existed in some years and must consist of the following columns:
\itemize{
\item \code{Origin_year} \cr type: integer or numeric. Origin year of the reinsurance structure.
\item \code{Priority} \cr type: numeric. Unindexed priority (or retention) of the xl treaty.
\item \code{Limit} \cr type: numeric. Unindexed limit of the xl treaty.
\item \code{Base_year} \cr type: integer or numeric. Base_year for the application of the indexation margin.
Set this column to 0 if no indexation shall be considered or set Margin_type to "none".
\item \code{Margin_type} \cr type: character. Either "FIC", "SIC", "APK" or "none" for no indexation.
\item \code{Margin} \cr type: numeric. Margin \eqn{\alpha}, e.g. 0.1 for a margin of 10\%. If Margin_type equals \code{FIC}, this
column will be set to 0. If Margin_type equals \code{none}, this column will be ignored.
\item \code{Quota_share} \cr type: numeric. If a quota share reinsurance is to be considered, this must be the reinsurance share,
e.g. 0.2 if the reinsurance pays 20\% of each claim.
}
}
\examples{
# this example uses data provided with this package
# Create large claims list
extended_claims_data <- prepare_data(claims_data = minimal_claims_data_xmpl,
                                     indices = indices_xmpl,
                                     threshold = 400000,
                                     first_orig_year = 1989,
                                     last_orig_year = 2023,
                                     expected_year_of_growing_large = 3,
                                     reserve_classes = c(1, 200001, 400001, 700001, 1400001),
                                     pool_of_annuities = minimal_pool_of_annuities_xmpl)

large_claims_list <- generate_claims_list(extended_claims_data = extended_claims_data,
                                          first_orig_year = 1989,
                                          last_orig_year = 2023)
# generate history
history <- generate_history_per_claim(extended_claims_data, "Cl_payment_cal", 1989, 2023)

# generate future payments with fictive constant payments
# of 1.000.000 for 10 years for claim in row 10
future_payments <- matrix(0, nrow = NROW(history), ncol = 250)
future_payments[10, 1:10] <- 1e6

# output "history"
xl_cashflow(future_payments = future_payments,
            claims_list = large_claims_list,
            history = history,
            reinsurance = reinsurance_xmpl,
            indices = indices_xmpl,
            output = "history")[10,]

# output "future"
xl_cashflow(future_payments = future_payments,
            claims_list = large_claims_list,
            history = history,
            reinsurance = reinsurance_xmpl,
            indices = indices_xmpl,
            output = "future")[10,]

# simple example, only one claim from origin year 2020
future_payments <- rbind(c(rep(5e5, 5), rep(0, 245)))
history <- rbind(rep(1e6, 4))
colnames(history) <- 2020:2023
claims_list <- data.frame(Claim_id = "Test1",
                          Origin_year = 2020,
                          Exit_reserve_class = 1,
                          Dev_year_since_large = 4,
                          Dev_year_of_growing_large = 1,
                          Large_since = 2020,
                          Cl_reserve = 5000000)
reinsurance <- reinsurance_xmpl[reinsurance_xmpl$Origin_year > 2019,]
reinsurance$Margin_type[1] <- "none"
reinsurance$Quota_share[1] <- 0

xl_cashflow(future_payments = future_payments,
            claims_list = claims_list,
            history = history,
            reinsurance = reinsurance,
            indices = indices_xmpl,
            output = "total")[1,1:10]

}
