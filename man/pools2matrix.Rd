% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampling_preparation.R
\name{pools2matrix}
\alias{pools2matrix}
\title{Convert pools to matrix}
\usage{
pools2matrix(pools)
}
\arguments{
\item{pools}{List as output of \code{\link[=generate_pools]{generate_pools()}}.}
}
\value{
List of three objects representing the pools, see details.
}
\description{
This function reduces the complexity of the pools structure by converting it to a matrix to sample from. See details
for more information.
}
\details{
The list \code{pools} contains the objects \code{pretail_pools}, \code{tail_pools} and \code{pool_of_annuities}. The first two are lists
that contain lists themselves that contain pools per development year and reserve class. This format makes it
easy to get a good overview of a pool by accessing it via the assigned indices of the lists. But on the other side,
this format doesn't allow for vectorized sampling. \cr
Hence this function turns the first two objects of \code{pools} into a \code{sample_matrix}. This matrix contains 7 columns
that are needed for sampling, that is \code{Ind_cl_payment_cal}, \code{Exit_reserve_class}, \code{New_annuity_1}, ...,
\code{New_annuity_5}. The rows of the pools are appended to the matrix, starting
with reserve class 0 and development year 2, continuing with reserve class 0 and development year 3 to \code{tail_start - 1}
and the same procedure with the other reserve classes. The tail pools are attached at the end. \cr \cr
As different pool sizes make it hard to find the start and the end of a pool in this matrix, every pool gets assigned
the same number of rows, and that is the maximum size of all pools. Every row that does not belong to the
original pool is set to 0. \cr \cr
\strong{Example:} A setup consisting of the reserve classes 0 to 3 and the development years 2 to 16 plus tail will
result in \eqn{4 * (15 + 1) = 64} pools. If the maximum size of the pools is 1.000 rows, each pool will be assigned 1.000
rows in \code{sample_matrix}, so the matrix has dimension \verb{(64.000, 7)}. \cr \cr
Of course not every pool is of this maximum size, so the vector \code{lengths_vector} is created which contains the sizes
of every pool. \cr \cr
The first row of the pool in \code{sample_matrix} is calculated by

\deqn{
row_1 =
\left\{
   \begin{array}{l}
      \bigl(rc \cdot \left( tail_1 - 2 \right) + dy - 2 \bigr) \cdot n_{pool,\ max} + 1 \quad \text{for pretail pools } \\
      \bigl(n_{rc} \cdot \left( tail_1 - 2 \right) + rc \bigr) \cdot n_{pool,\ max} + 1 \quad \text{for tail pools}
   \end{array}
\right.
}
where
\deqn{
\begin{array}{l}
   rc \quad \text{is the reserve class} \\
   dy \quad \text{is the desired development year} \\
   tail_1 \quad \text{is the first tail year} \\
   n_{rc} \quad \text{is the number of reserve classes and} \\
   n_{pool,\ max} \quad \text{is the maximum pool size}
\end{array}
}

The rows to sample from can be derived from \eqn{row_1} and the corresponding entry of \code{lengths_vector}. The function
\code{\link[=get_matrix_info]{get_matrix_info()}} returns these values.
}
\examples{
\dontrun{
# this example uses data provided with this package
new_data <- prepare_data(claims_data = minimal_claims_data_xmpl,
                         indices = indices_xmpl,
                         threshold = 400000,
                         first_orig_year = 1989,
                         last_orig_year = 2023,
                         expected_year_of_growing_large = 3,
                         reserve_classes = c(1, 200001, 400001, 700001, 1400001),
                         pool_of_annuities = minimal_pool_of_annuities_xmpl)
pools <- generate_pools(extended_claims_data = new_data,
                        reserve_classes = c(1, 200001, 400001, 700001, 1400001),
                        years_for_pools = 2014:2023,
                        start_of_tail = 17,
                        end_of_tail = 50,
                        lower_outlier_limit = -Inf,
                        upper_outlier_limit = Inf,
                        pool_of_annuities = minimal_pool_of_annuities_xmpl)
pools_as_matrix <- pools2matrix(pools)}
}
\keyword{internal}
